package ru.jamsys.core.extension.raw.writer;

import lombok.Getter;
import lombok.Setter;
import ru.jamsys.core.extension.ByteSerialization;

import java.util.concurrent.ConcurrentHashMap;

// Привычные manager пока не использую, так как не вижу потребности снимать статистику +
// при выведении из-за неактивности объект не будет удалятся из памяти, а нам как будто надо его удалять
// На чём остановились:
// 1) Поток или серия потоков подписывается на серию файлов по шаблону и мы должны дать им конкурентную очередь с
//    списком RawFileBlock. С учётом, что RawFileChannel - это живой объект и данные заполняются runTime мы должны
//    делать прямо подписку в RawFileChannel, то есть наполнение очереди внутренней должно быть не одно, а ещё наполнять
//    отдельные очереди подписчиков. Таким образом у подписчика есть своя собственная очередь и как он её читает
//    это его собственная задача. Если будет огромное кол-во файлов, держать и наполнять очереди подписчиков - это
//    работа в переполнение памяти. Нам такое не надо. Это значит, что подписчик просто должен знать от куда получать
//    следующий RawFileBlock. Но это тоже так себе история. Что если мы будем хранить временный пул RawFileBlock и
//    на момент когда пул истощается мы будем запрашивать новую партию RawFileBlock. Это всё сводится к тому, что
//    подписчик должен знать какой последний элемент он вычитал, что бы запросить следующую пачку данных, который будут
//    обработаны в несколько потоков.
// 2) RawFileBlock должен иметь ссылку на файл, что бы через менаджер получать экземпляр RawFileChannel.
// ----- резюмирую --------
// Циклический набор файлов "имя_timestamp.bin" при превышении индекса - удаляем файл с наименьшим timestamp + создаём
// новый. RawFileBlock содержит имя файла из которого он вычитан + индекс в этом документе. ManagerRawFileChannel
// при иницаиализации добавляет все файлы с ФС по шаблону "имя_%". Подписчик не хранит offset что уже прочитал. Контроль
// будет проходить за счёт фильтра по SubscriberRead (бывший writerFlag). При инициализации RawFileChannel должна
// добавляться информация о том какие подписчики ещё что-то не дочитали. Когда подписчик подписывается, он
// самостоятельно говорит на сколько глубоко заполнить его личную очередь RawFileMarkup + указывает маркер заполнения
// с конца или начала. Памяти может не хватить держать все состояния всех подписчиков, пока останавливаюсь на том, что
// надо бегать по файлам и фильтровать. Принимается вариант, что обратного пути отката статуса нет, что бы повторно не
// прогонять весь файл на разметку и вычисления subscriberReadStatus

@Getter
@Setter
public class PersistStream<T extends ByteSerialization> {

    private final ConcurrentHashMap<String, RawFileChannel<T>> map = new ConcurrentHashMap<>();

}
